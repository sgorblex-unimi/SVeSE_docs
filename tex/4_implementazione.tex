\chapter{Implementazione del sistema}\label{implementazione}
L'implementazione viene costruita su una serie di framework e librerie di supporto, scelte accuratamente tra le più comuni e potenti usate dalle grandi software house. Il sistema è monolitico e consiste in un'unica applicazione server-side basata su Spring Boot (\url{https://spring.io/projects/spring-boot}). Sia gli amministratori sia gli utenti finali accedono a un'unica istanza del sistema tramite un web browser di propria scelta. In supplemento a tale framework vengono usate le sue estensioni Web, Security e Data (Data JPA) per rendere più facile, leggibile ed efficiente il codice rispettivamente negli ambiti del servlet, della gestione della sessione web e delle credenziali e nella gestione della persistenza. La persistenza è implementata in un database PostgreSQL (si veda il paragrafo \ref{db}) con il supporto della libreria Hibernate. Per quanto riguarda il front-end, l'interfaccia utente viene implementata tramite il framework Vaadin (si veda il paragrafo \ref{gui}). Il sistema comprende file e script di supporto per facilitare il setup all'amministratore di sistema.

Per quanto riguarda la qualità del codice, viene usato un modello \emph{Model, View, Controller} (MVC): model e view risiedono negli omonimi pacchetti Java, mentre il controller è implementato in parte lato model e in parte lato view. L'utilizzo dei design pattern è documentato al paragrafo \ref{pattern}. Il codice è testato tramite piattaforma JUnit (si veda il paragrafo \ref{testing}). Sono inoltre presenti vincoli implementati con \emph{assert}, come spiegato al paragrafo \ref{vincoli}. Viene tenuta traccia delle operazioni del sistema tramite la libreria di logging SLF4J (si veda il paragrafo \ref{logging}).

Le operazioni di compilazione, installazione, esecuzione, soluzione delle dipendenze e in generale di \emph{build} sono gestite dal \emph{build tool} Apache Maven (\url{https://maven.apache.org}). Il progresso del progetto è ovviamente tracciato dal \emph{versioning tool} Git (\url{https://git-scm.com}).




\section{Diagramma di deployment}




\section{Vincoli}\label{vincoli}




\section{Testing}\label{testing}
Per il testing viene utilizzato il paradigma del test unitario (\emph{unit testing}) tramite la piattaforma JUnit (\url{https://junit.org/junit5}). Per scelta di design, il codice ha una struttura dichiarativa, con poche strutture di controllo; tuttavia quando applicabile viene usato il criterio di copertura delle decisioni (\emph{decision coverage}), che permette di verificare che il sistema si comporti nel modo previsto nei casi principali, cioè quelli che determinano l'esito di ogni decisione. Nei casi in cui questo non sia sufficiente sono forniti test case supplementari che coprano le singole condizioni (\emph{condition coverage}) all'interno delle decisioni.




\section{Diagramma delle classi di programma}




\section{Design pattern}\label{pattern}




\section{Interfaccia grafica}\label{gui}




\section{Persistenza dei dati}\label{db}
I dati persistenti sono memorizzati in un database PostgreSQL (\url{https://www.postgresql.org}) e gestiti tramite l'interfaccia JPA (Java Persistent API, standard introdotto da Oracle) implementata da Spring Data. La gestione è supplementata dall'utilizzo di Hibernate (\url{https://hibernate.org}), una libreria che ottimizza la gestione della persistenza e costruisce automaticamente query SQL pensate per un certo \emph{dialetto}, cioè specifiche per un DBMS. Spring Data permette di programmare servizi DAO come interfacce Java (repository) in cui i metodi hanno nomi significativi, che poi vengono implementate automaticamente dal framework. Grazie a questa astrazione, le query SQL sono ottimizzate e versatili (non \emph{hard-coded}); è possibile infatti cambiare, se lo si volesse, il DBMS con il minimo sforzo, modificando unicamente il file \verb!application.properties!. Le query SQL sono comunque visibili, a meno dei dati sensibili, nei log del sistema.




\section{Auditing}\label{logging}
